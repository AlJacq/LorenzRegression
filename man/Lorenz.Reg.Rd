% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Lorenz-regression.R
\name{Lorenz.Reg}
\alias{Lorenz.Reg}
\title{Undertakes a Lorenz regression}
\usage{
Lorenz.Reg(
  formula,
  data,
  weights,
  na.action,
  standardize = TRUE,
  penalty = c("none", "SCAD", "LASSO"),
  h.grid = c(0.1, 0.2, 1, 2, 5) * nrow(data)^(-1/5.5),
  SCAD.nfwd.grid = NULL,
  eps = 0.005,
  lambda.list = NULL,
  ...
)
}
\arguments{
\item{formula}{A formula object of the form \emph{response} ~ \emph{other_variables}.}

\item{data}{A data frame containing the variables displayed in the formula.}

\item{weights}{A vector of sample weights. By default, each observation is given the same weight.}

\item{standardize}{A logical determining whether the variables should be standardized before the estimation process. Default value is \code{TRUE}.}

\item{penalty}{A character string specifying the type of penalty on the coefficients size.
If \code{"none"} is chosen, a non-penalized Lorenz regression is computed using function \code{\link{Lorenz.GA}}.
If \code{"SCAD"} is chosen, a penalized Lorenz regression with SCAD penalty is computed using function \code{\link{Lorenz.SCADFABS}}.
If \code{"LASSO"} is chosen, a penalized Lorenz regression with LASSO penalty is computed using function \code{\link{Lorenz.FABS}}.}

\item{h.grid}{Only used if \code{penalty="SCAD"} or \code{penalty="LASSO"}. A vector (grid) of values for the bandwidth of the kernel, determining the smoothness of the approximation of the indicator function. Default value is (0.1,0.2,1,2,5)*n^(-1/5.5), where n is the sample size.}

\item{SCAD.nfwd.grid}{Only used if \code{penalty="SCAD"}. A vector (grid) of values for the \code{SCAD.nfwd} argument used in the \code{\link{PLR.wrap}} function. Default value is \code{NULL}. If a vector is supplied, the argument \code{h.grid} is modified to only use the first value of the vector.}

\item{eps}{Only used if \code{penalty="SCAD"} or \code{penalty="LASSO"}. A scalar indicating the step size in the FABS or SCADFABS algorithm. Default value is 0.005.}

\item{...}{Additional parameters corresponding to arguments passed in \code{\link{Lorenz.GA}}, \code{\link{Lorenz.SCADFABS}} or \code{\link{Lorenz.FABS}} depending on the argument chosen in penalty.}
}
\value{
A list with the following elements.
\describe{
   \item{\code{theta}}{The estimated vector of parameters.}
   \item{\code{Gi.expl}}{The estimated explained Gini coefficient.}
   \item{\code{LR2}}{The Lorenz-\eqn{R^2} of the regression.}
   \item{\code{MRS}}{The matrix of estimated marginal rates of substitution. More precisely, if we want the MRS of X1 (numerator) with respect to X2 (denominator),
   we should look for row corresponding to X1 and column corresponding to X2.}
   \item{\code{index}}{A vector gathering the estimated index.}
}
For the Penalized Lorenz Regression, the tuning parameter (i.e. the value on the grid \code{h.grid} or \code{SCAD.nfwd.grid}) and the penalization parameter are chosen optimally via the BIC method. In this case, the list also contains the following elements :
\describe{
   \item{\code{path}}{A list where the different elements correspond to the values of the tuning parameter. Each element is a matrix where the first line displays the vector of lambda values. The second and third lines display the evolution of the Lorenz-\eqn{R^2} and explained Gini coefficient along that vector. The next lines display the evolution of the BIC score. The remaining lines display the evolution of the estimated parameter vector.}
   \item{\code{which.lambda}}{the index of the optimal lambda obtained by the BIC method}
   \item{\code{which.tuning}}{the index of the optimal tuning parameter obtained by the BIC method.}
}
In both cases, the list also provide technical information, such as the specified formula, weights and call, as well as the design matrix \code{x} and the response vector \code{y}.
}
\description{
\code{Lorenz.Reg} performs the Lorenz regression of a response with respect to several covariates.
}
\section{References}{

Heuchenne, C. and A. Jacquemain (2022). Inference for monotone single-index conditional means: A Lorenz regression approach. \emph{Computational Statistics & Data Analysis 167(C)}.
Jacquemain, A., C. Heuchenne, and E. Pircalabelu (2024). A penalised bootstrap estimation procedure for the explained Gini coefficient. \emph{Electronic Journal of Statistics 18(1) 247-300}.
}

\examples{
data(Data.Incomes)
set.seed(123)
Data <- Data.Incomes[sample(1:nrow(Data.Incomes),50),]
# 1. Non-penalized regression
NPLR <- Lorenz.Reg(Income ~ ., data = Data, penalty = "none",
                   popSize = 30)
# 2. Penalized regression
PLR <- Lorenz.Reg(Income ~ ., data = Data, penalty = "SCAD",
                  h.grid = nrow(Data.Incomes)^(-1/5.5),
                  sel.choice = c("BIC","CV"), eps = 0.01, nfolds = 5)
# Comparison
NPLR$theta;PLR$theta
NPLR$summary;PLR$summary


}
\seealso{
\code{\link{Lorenz.GA}}, \code{\link{Lorenz.SCADFABS}}, \code{\link{Lorenz.FABS}}, \code{\link{PLR.wrap}}, \code{\link{Lorenz.boot}}
}
